[0183] 2. Hot-Cold data Binary block sorting (implicit implementation of the Block level TS)--no need to model [0184] Each Binary block is listed in the UB info in time allocation order for new data update blocks. Equivalent to TS being the same for all logical groups written for the block. [0185] During compaction, the new block's position in the list is chosen approximately according to the source block locations. In other words, the new block has approximately the same temperature as the source block. [0186] During compaction TS is approximated on the basis of TSs in the source blocks [0187] Logical groups from the block at the end of the list get evicted [0188] The advantages are that it has no extra records, no overflow, no increments etc. Also it is very good for Binary Cache where there is no single table record, but multiple BCIs (binary cache indices), which are impossible to update all together. The disadvantage is that it requires data copies to re-sort block records
[0189] The principles described above apply to a system with two or more layers of data storage, which can be non-volatile or mixed. The same rules can be applied to a specific type of storage in one of the layers, say Binary Cache sub-system or Update Blocks.
[0190] Advantage of this solution is that system performance impact is minimized and there is no increase in controller RAM space.
Block Streams to Separate Hot/Cold Data by LGT
[0191] In another embodiment, units of data are sorted according to their temperatures into different block streams such that the blocks in each operating stream only involves data of similar temperature. The goal is to separate hot data from cold data as soon as possible and at every opportunity. The hot data and cold data have different obsolescence and garbage collection/relocation schedules. For example, hot data will become obsolete faster and require more frequent garbage collection/rewrites. When the cold data are not mixed in with the hot data, it will not incur unnecessary rewrites. Most likely, the hot data will obsolete itself without triggering relocation of cold data from one block to another block, and the cold data in cold blocks will stay there without compactions/relocations due to the hot data.